### ❓ 通过 Polkadot.js App 或 Substrate 钱包是否只可以查看 SS58 地址的余额，而无法查看 H160 地址的余额？

> ✅ **简短回答：**
> - **是的，Polkadot.js App 和 Substrate 钱包只能查看 SS58 地址的余额**。
> - 它们 **无法直接查看 H160 地址的余额**，因为 H160 地址是 EVM 兼容链上的地址，而 Substrate 节点本身不理解 EVM 地址格式。

---

## 🔍 详细解释

### 1. **SS58 地址 vs H160 地址：本质不同**
```
私钥 (32 bytes)
     │
     ▼
公钥 (64 bytes 或 33 bytes) ←—— 由私钥推导（ECDSA）
     │
     ├───────────────┐
     ▼               ▼
BLAKE2b(公钥)    KECCAK256(公钥)
     │ (取前32字节)   │ (取后20字节)
     ▼               ▼
[32字节哈希]     [20字节哈希]
     │               │
     ▼               ▼
 + 校验和        + 0x 前缀
     │               │
     ▼               ▼
 SS58 编码       十六进制编码
     │               │
     ▼               ▼
  SS58 地址       H160 地址
```
| 特性 | SS58 地址（Substrate） | H160 地址（EVM） |
|------|------------------------|------------------|
| 所属链 | Substrate 链（如 Polkadot、Kusama、Moonbeam、Astar） | EVM 兼容链（如 Ethereum、Polygon、BSC、Moonbeam） |
| 地址格式 | 以 `1` 或 `5` 开头，如 `14...` | 以 `0x` 开头，如 `0x...` |
| 生成方式 | 公钥 → BLAKE2b → SS58 编码 | 公钥 → KECCAK256 → 取后 20 字节 |
| 是否被 Substrate 节点识别 | ✅ 是 | ❌ 否 |

> 📌 关键点：**Substrate 节点只认识 SS58 地址**，不理解 `0x` 开头的 H160 地址。

---

### 2. **Polkadot.js App 的工作原理**

Polkadot.js App 是一个连接到 **Substrate 节点** 的前端工具。

- 它通过 JSON-RPC 或 WebSocket 连接到节点。
- 它查询的是 **Substrate 的状态存储（state trie）**。
- 它只支持查询 **SS58 格式地址** 对应的账户信息（如余额、nonce、存储等）。

> ❌ 它不能查询 `0x...` 格式的 H160 地址，因为：
> - 这些地址不是 Substrate 链上的“账户”；
> - 它们在 Substrate 上没有对应的账户状态。

---

### 3. **H160 地址的余额在哪？**

H160 地址的余额存在于 **EVM 兼容链** 上，比如：

- **Moonbeam**（EVM 兼容的 Substrate 链）
- **Astar**（支持 EVM）
- **BSC / Polygon / Ethereum**

✅ 你必须使用 **EVM 兼容的工具** 来查看 H160 地址的余额：

| 工具 | 支持 H160 余额查询 |
|------|------------------|
| MetaMask | ✅ 是 |
| Etherscan | ✅ 是 |
| Hardhat + ethers.js | ✅ 是 |
| Polkadot.js App（仅限 EVM 兼容链） | ⚠️ 仅当链支持 EVM 时，可通过 `eth_getBalance` 调用，但需手动配置 RPC |

> 📌 举例：在 Moonbeam 上，你可以：
> - 用 Polkadot.js App 查看 **SS58 地址** 的余额（如 DOT）；
> - 用 Etherscan 或 MetaMask 查看 **H160 地址** 的余额（如 GLMR）。

---

### 4. **特殊情况：EVM 兼容 Substrate 链（如 Moonbeam、Astar）**

这些链虽然基于 Substrate，但支持 EVM，因此：

- 它们 **同时支持 SS58 和 H160 地址**；
- 但：
  - **SS58 地址**：用于原生代币（如 DOT、GLMR）；
  - **H160 地址**：用于 EVM 代币（如 USDC、WETH）；

✅ 在这类链上，你可以：
- 用 Polkadot.js App 查看 SS58 地址的原生余额；
- 用 Etherscan 查看 H160 地址的 EVM 代币余额；
- 但 **不能用 Polkadot.js App 直接查 H160 地址的原生余额**。

---

### 5. **总结：一句话回答**

> ❌ **Polkadot.js App 或 Substrate 钱包无法查看 H160 地址的余额**，因为它们只处理 Substrate 链的 SS58 地址；  
> ✅ **H160 地址的余额必须通过 EVM 工具（如 MetaMask、Etherscan、ethers.js）查询**，且仅在 EVM 兼容链上有效。

---

## ✅ 公钥和地址：私钥 → 公钥 → 地址
### 1. **私钥（Private Key）**
- 一个 32 字节（256 位）的随机数。
- 例如：`0x1234...abcdef`（ECDSA 私钥）

> ⚠️ 私钥必须保密，不能泄露。

---

### 2. **公钥（Public Key）**
- 由私钥通过 **椭圆曲线加密算法（ECDSA）** 推导而来。
- 通常是 64 字节（512 位）的未压缩格式（或 33 字节压缩格式）。

---

### 📚 附：常见误区澄清
| 问题 | 答案 |
|------|------|
| **公钥和地址是一回事吗？** | ❌ 不是！公钥是密钥对中的“公开部分”，地址是公钥的“哈希 + 编码”结果。 |
| **公钥和 SS58 地址的关系？** | ✅ SS58 地址 = `BLAKE2b(公钥)` 的前 32 字节 + 校验和 + SS58 编码 |
| **公钥和 H160 地址的关系？** | ✅ H160 地址 = `KECCAK256(公钥)` 的后 20 字节 |
| **公钥有什么用？** | ✅ 用于验证签名、生成地址、验证交易、构建密钥对 |

> 📌 提示：同一个私钥可以生成 SS58 和 H160 地址，但它们在不同链上，余额完全独立。
